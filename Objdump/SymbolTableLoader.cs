/* SymbolTableLoader.cs - (c) James S Renwick 2014
 * -----------------------------------------------
 * Version 1.2.1
 * 
 * This code file contains the logic for parsing and loading
 * a symbol table from the output produced by objdump.
 * 
 * It ignores all text until it hits the line "SYMBOL TABLE:"
 * and completes upon encountering an empty line.
 * 
 * TODO: Better error handling
 */
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace DebugOS.Loaders.Objdump
{
    /// <summary>
    /// Helper class facilitating symbol table loading.
    /// </summary>
    public static class SymbolTableLoader
    {
        // String indicating the start of the symbol table
        const string TableStart = "SYMBOL TABLE:";

        // Regex matching an entry in the symbol table
        static readonly Regex symbolRegex = new Regex(
               @"(?<value>[\da-fA-F]{8}) (?<f1>.)(?<f2>.)(?<f3>.)(?<f4>.)(?<f5>.)(?<f6>.)(?<f7>.)"
             + @" (?<section>\S+)\t(?<align>[\da-fA-F]+) (?<name>.*)");

        /// <summary>
        /// Loads a new symbol table from an object file.
        /// </summary>
        /// <param name="filepath">The path to the object file.</param>
        /// <returns>A symbol table containing the symbols in the given object file.</returns>
        public static SymbolTable Load(string filepath) {
            return LoadFromObjdump(new StreamReader(filepath));
        }

        /// <summary>
        /// Loads a new symbol table from objdump output.
        /// </summary>
        /// <param name="stream">An objdump output stream.</param>
        /// <returns>A symbol table containing the symbols in the given object file.</returns>
        public static SymbolTable LoadFromObjdump(StreamReader stream)
        {
            /* 
             * This function uses regexes to match against the symbol output
             * generated by objdump.
             */

            string line;                                // Holds the current line being processed
#warning BAD SYMBOL TABLE FORMAT
            bool   start   = true;                      // Indicates whether this is the first line
            var    entries = new List<SymbolEntry>();   // Holds the symbols parsed

            while ((line = stream.ReadLine()) != null)
            {
                if (!start) // Read until the start of the symbol table is found
                {
                    if (line == TableStart) { start = true; }
                    continue;
                }

                // Break on the first empty line
                if (string.IsNullOrWhiteSpace(line)) break;

                // Match with regex 
                var match = SymbolTableLoader.symbolRegex.Match(line);

                /* === Get values === */
                uint        value = Utils.ParseHex32(match.Groups[1].Value);
                SymbolFlags flags = 0;

                char f1 = match.Groups[2].Value[0];
                char f2 = match.Groups[3].Value[0];
                char f3 = match.Groups[4].Value[0];
                char f4 = match.Groups[5].Value[0];
                char f5 = match.Groups[6].Value[0];
                char f6 = match.Groups[7].Value[0];
                char f7 = match.Groups[8].Value[0];

                switch (f1)
                {
                    case 'l': flags |= SymbolFlags.Local;  break;
                    case 'g': flags |= SymbolFlags.Global; break;
                    case 'u': flags |= SymbolFlags.Unique; break;
                    case '!': flags |= SymbolFlags.Local | SymbolFlags.Global; break;
                }
                if (f2 == 'w') flags |= SymbolFlags.Weak;
                if (f3 == 'C') flags |= SymbolFlags.Constructor;
                if (f4 == 'W') flags |= SymbolFlags.Warning;
                switch (f5)
                {
                    case 'I': flags |= SymbolFlags.Reference;     break;
                    case 'i': flags |= SymbolFlags.RelocFunction; break;
                }
                switch (f6)
                {
                    case 'd': flags |= SymbolFlags.Debugging; break;
                    case 'D': flags |= SymbolFlags.Dynamic;   break;
                }
                switch (f7)
                {
                    case 'F': flags |= SymbolFlags.Function; break;
                    case 'f': flags |= SymbolFlags.File;     break;
                    case 'O': flags |= SymbolFlags.Object;   break;
                }

                string section = match.Groups[9].Value;
                int    align   = (int)Utils.ParseHex32(match.Groups[10].Value);
                string name    = match.Groups[11].Value;

                entries.Add(new SymbolEntry(value, flags, section, align, name));
            }

            return new SymbolTable(entries.ToArray());
        }
    }
}